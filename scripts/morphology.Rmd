---
title: "morphStuart"
author: "Aaron Myrold"
date: "`r Sys.Date()`"
output: html_document
---

#==============================================================================#
# SETUP
```{r setup}
knitr::opts_knit$set(root.dir = dirname(getwd()))
```

```{r source}
# Source project setup and run config
source("src/project_setup.R")
setup_project('config.yaml', force_reload = TRUE)

```
#==============================================================================#
# DATA IMPORT
```{r}
# Source cleaning functions
source(paste0(p$src, "morph_cleaning.R"))
# Read in data and check initial structure
morph <- read.csv(paste0(p$data.raw, "020625_PitLMorph.csv"))
#str(morph)

# ADD LOGGING:
processing_log <- log_step(
  processing_log, 
  step_name = "Data Import",
  input_data = morph,
  notes = "Initial import of raw morphology data"
)

# ADD VALIDATION:
validate_step(
  morph, 
  step_name = "Data Import",
  required_columns = c("n", "ID", "SL", "Scale_10mm"),
  custom_checks = fish_data_checks[c("count_variable_logic")]  # This check now works without fish_id
)

```

## ID Structure Analysis
```{r}
# Extract fish ID and part type
# ID format: VXXXXXX_LXXXX(A)_1_P/C.jpg or VXXXXXX_LXXXX(A)_1_P2.jpg
# where VXXXXXX is the specimen ID, LXXXX(A) is the LSPEC/locality, and P/C indicates part/counterpart
morph_with_ids <- morph %>%
  mutate(
    fish_id = str_extract(ID, "^V\\d+"),                          # Extract VXXXXX part at beginning
    LSPEC_raw = str_extract(ID, "L\\d+[A-Za-z]?"),                  # Extract LXXXX with optional letter
    # Split LSPEC into letter prefix, number, and suffix
    LSPEC_letter = str_extract(LSPEC_raw, "^L"),
    LSPEC_number = str_extract(LSPEC_raw, "\\d+"),
    LSPEC_suffix = str_extract(LSPEC_raw, "[A-Za-z]$"),
    # Create standardized LSPEC with zero padding
    LSPEC = case_when(
      !is.na(LSPEC_suffix) ~ paste0(LSPEC_letter, str_pad(LSPEC_number, 4, pad = "0"), LSPEC_suffix),
      !is.na(LSPEC_number) ~ paste0(LSPEC_letter, str_pad(LSPEC_number, 4, pad = "0")),
      TRUE ~ NA_character_
    ),
    # Extract P or C (with optional numbers) before .jpg, then standardize
    part_type_raw = str_extract(ID, "[PC]\\d*(?=\\.jpg$)"),      # Extract P, P2, P3, etc. or C before .jpg
    part_type = case_when(
      str_starts(part_type_raw, "P") ~ "P",                      # Convert P, P2, P3, etc. to just "P"
      part_type_raw == "C" ~ "C",                                # Keep C as is
      TRUE ~ part_type_raw                                       # Preserve any unexpected values
    )
  ) %>%
  select(-LSPEC_raw, -LSPEC_letter, -LSPEC_number, -LSPEC_suffix, -part_type_raw)  # Remove intermediate columns


# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "ID Structure Analysis", 
  input_data = morph,
  output_data = morph_with_ids,
  notes = "Extracted fish_id and part_type from ID column"
)

# Continue with updated ids
morph <- morph_with_ids
```

## Basic Quality Check
```{r}
# Check for implausible values in measurement columns
length_cols <- c("SL", "CAV", "DS1", "DS2", "DS3", "LPT", "PSP.L", "PSP.R", "TPG", "ECT", "CLE", "PMX")

# Check for negative values in length columns
negative_lengths <- morph %>%
  select(ID, all_of(length_cols)) %>%
  pivot_longer(cols = -ID, names_to = "measure", values_to = "value") %>%
  filter(value < 0)
length(negative_lengths$ID) # No negative measurements

```

## Flag missing Scale_10mm
```{r}
# Check for missing scale information
scale_summary <- morph %>%
  group_by(fish_id) %>%
  summarize(
    has_part_scale = any(!is.na(Scale_10mm[part_type == "P"])),
    has_cpart_scale = any(!is.na(Scale_10mm[part_type == "C"])),
    has_any_scale = has_part_scale | has_cpart_scale,
    .groups = "drop"
  )

# Get list of fish IDs missing scales
fish_missing_scales <- scale_summary %>%
  filter(!has_any_scale) %>%
  pull(fish_id)

# Create report of fish missing scale information
missing_scales_detail <- morph %>%
  filter(fish_id %in% fish_missing_scales) %>%
  select(fish_id, ID, part_type, Scale_10mm) %>%
  arrange(fish_id, part_type)

# Write the detailed report
write.csv(missing_scales_detail, 
          file = paste0(p$data.flagged, "fish_missing_scales_detailed.csv"), 
          row.names = FALSE)

# Print summary of scale check
cat("Fish without any scale information:", 
    sum(!scale_summary$has_any_scale), 
    "out of", nrow(scale_summary), "\n")

# Split the dataset
morph_with_scales <- morph %>%
  filter(!fish_id %in% fish_missing_scales)

morph_without_scales <- morph %>%
  filter(fish_id %in% fish_missing_scales)

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Scale Filtering",
  input_data = morph,
  output_data = morph_with_scales,
  notes = paste("Removed", length(fish_missing_scales), "fish without scale measurements")
)

# Continue with the fish that have scale measurements
morph <- morph_with_scales

# Write the datasets to separate files for reference
write.csv(morph_with_scales, 
          file = paste0(p$data.raw, "fish_with_scales.csv"), 
          row.names = FALSE)

write.csv(morph_without_scales, 
          file = paste0(p$data.flagged, "fish_without_scales.csv"), 
          row.names = FALSE)
```

#==============================================================================#
# DATA PREPROCESSING
## Handle Special Cases
```{r Spine and Girdle Logic}

morph_corrected <- handle_special_cases(morph)

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Special Cases Handling",
  input_data = morph_with_scales,
  output_data = morph_corrected,
  notes = "Applied spine and girdle logic rules"
)

```

## Overlap Assesment
```{r}
overlap_results <- identify_overlaps(morph_corrected, threshold = 0.05)

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Overlap Assessment",
  input_data = morph_corrected,
  notes = paste("Identified", length(unique(overlap_results$overlap_fish$fish_id)), 
                "fish with conflicts")
)
# Summarize overlap findings
cat("Number of fish with overlapping measurements:", 
    length(unique(overlap_results$overlap_metrics$fish_id)), "\n")
cat("Number of fish without overlaps:", 
    length(unique(overlap_results$non_overlap_fish$fish_id)), "\n")

```

#==============================================================================#
# DATA CLEANING
## Merge Non-Overlapping Fish
```{r}
merged_non_overlap <- merge_non_overlap(overlap_results$non_overlap_fish)

# Write merged data for Non-Overlapping Fish
merged_file <- write.csv(merged_non_overlap, 
          file = paste0(p$data.intermediate, "merged_non_overlap.csv"))

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Merge Non-Overlapping Fish",
  input_data = overlap_results$non_overlap_fish,
  output_data = merged_non_overlap,
  files_created = merged_file,
  notes = "Merged part and counterpart data"
)

```

## Flag Conflicting Measurements
```{r Flag Duplicates}
# Create review list with threshold filtering applied (default)
review_results <- create_review_list(overlap_results, use_threshold = TRUE)

# Or to see all overlaps without threshold filtering:
# review_results_all <- create_review_list(overlap_results, use_threshold = FALSE)

export_review_list(review_results, file_prefix = "fish_fossil_review",
                   output_dir = p$data.flagged)

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Flag Conflicting Measurements",
  input_data = overlap_results$overlap_fish,
  notes = paste("Created review lists for", nrow(review_results$summary), "fish")
)

```

## Visualize Results
```{r}
# Get the filtered metrics that only include real overlaps
filtered_metrics <- review_results$filtered_metrics

# Create a suffix for titles based on whether threshold filtering was used
threshold_text <- if(review_results$use_threshold) " (Exceeding Threshold)" else " (All Overlaps)"

# Visualization 1: Distribution of relative differences
p1 <-ggplot(filtered_metrics, aes(x = relative_diff)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "black") +
  geom_vline(xintercept = 0.05, color = "red", linetype = "dashed") +
  labs(title = paste0("Distribution of Relative Differences", threshold_text),
       x = "Relative Difference (proportion of scale)",
       y = "Count") +
  theme_minimal()
ggsave(paste0(p$data.processed, "overlap_relative_differences.svg"), p1, width = 10, height = 6)

# Visualization 2: Count of overlaps by measurement type
overlap_by_measure <- filtered_metrics %>%
  group_by(measure) %>%
  summarise(
    count = n(),
    avg_diff = mean(relative_diff, na.rm = TRUE),
    .groups = "drop"
  )

p2 <- ggplot(overlap_by_measure, aes(x = reorder(measure, count), y = count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = paste0("Number of fish with duplicate measurements by type", threshold_text),
       x = "Measurement",
       y = "Count of fish with duplicates") 
ggsave(paste0(p$processed, "/overlaps_by_measure.svg"), p2, width = 10, height = 6)

# Visualization 3: Distribution of flags per fish
p3 <- ggplot(review_results$summary, aes(x = total_diffs)) +
  geom_histogram(binwidth = 1, fill = "coral") +
  theme_minimal() +
  labs(title = paste0("Distribution of duplicate measurements per fish", threshold_text),
       x = "Number of duplicate measurements",
       y = "Count of fish")
ggsave(paste0(p$processed, "/duplicates_per_fish.svg"), p3, width = 8, height = 6)

# Visualization 4: Distribution of differences by variable type
p4 <- ggplot(filtered_metrics, 
       aes(x = var_type, y = absolute_diff, fill = var_type)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set2") +
  theme_minimal() +
  labs(title = paste0("Distribution of Differences by Variable Type", threshold_text),
       x = "Variable Type", 
       y = "Absolute Difference",
       fill = "Variable Type") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave(paste0(p$processed, "/differences_by_variable_type.svg"), p4, width = 10, height = 6)
```
#==============================================================================#
# MERGE AGE ESTIMATES
## Format Age Data for Merging
```{r Format Age Data}
# Read age data (assuming it's already loaded as 'age')
age <- read.csv(paste0(p$data.raw, "PitLMorph_fieldorder.csv"))

# Convert L..SPEC to match bin formatting
age_formatted <- age %>%
  # Convert L..SPEC to character and format as bin
  mutate(
    # Handle the column name with dots - use backticks or rename
    L_SPEC_clean = `L..SPEC`,
    # Create bin column matching the morph data format: "L" + 4-digit zero-padded number
    LSPEC = paste0("L", str_pad(as.character(L_SPEC_clean), 4, pad = "0")),
    # Convert relevant columns to numeric for analysis
    CSTRAT = as.numeric(CSTRAT),
    ISTRAT = as.numeric(ISTRAT), 
    YEAR = as.numeric(YEAR),
    INT = as.numeric(INT)
  ) %>%
  # Select only the columns we need for merging
  select(LSPEC, CSTRAT, ISTRAT, YEAR, INT) %>%
  # Remove any rows where bin couldn't be created (NA values in L..SPEC)
  filter(!is.na(LSPEC), LSPEC != "LNA")

# Check the formatting
head(age_formatted)


```

## Merge with Morphological Data
```{r Merge Age Data}
# Merge age data with the processed morphological data
# Assuming you have your merged_non_overlap data from the previous processing

# Read the merged morphological data if not already in memory
if (!exists("merged_non_overlap")) {
  merged_non_overlap <- read.csv(paste0(p$data.intermediate, "/merged_non_overlap.csv"))
}

# Perform the merge
morph_with_age <- merged_non_overlap %>%
  left_join(age_formatted, by = "LSPEC")

# ADD LOGGING:
processing_log <- log_step(
  processing_log,
  step_name = "Age Data Merging",
  input_data = merged_non_overlap,
  output_data = morph_with_age,
  notes = paste("Merged age data for", sum(!is.na(morph_with_age$CSTRAT)), "specimens")
)

# EXPORT COMPREHENSIVE PROCESSING LOG:
log_files <- export_log(processing_log, output_dir = p$docs.logs)


# Check merge results
merge_summary <- morph_with_age %>%
  summarise(
    total_specimens = n(),
    specimens_with_age_data = sum(!is.na(CSTRAT)),
    specimens_with_istrat = sum(!is.na(ISTRAT)),
    specimens_with_year = sum(!is.na(YEAR)),
    specimens_with_int = sum(!is.na(INT)),
    percent_with_age_data = round(100 * sum(!is.na(CSTRAT)) / n(), 1)
  )

print("Merge Summary:")
print(merge_summary)

# Check which LSPECs from morphological data don't have age matches
missing_age_LSPEC <- morph_with_age %>%
  filter(is.na(CSTRAT)) %>%
  select(LSPEC) %>%
  distinct() %>%
  pull(LSPEC)

if(length(missing_age_LSPEC) > 0) {
  cat("\nLSPECs in morphological data without age matches:\n")
  print(missing_age_LSPEC)
}

# Check which LSPECs from age data don't have morphological matches
available_age_LSPECs <- unique(age_formatted$LSPEC)
used_age_LSPECs <- unique(morph_with_age$LSPEC[!is.na(morph_with_age$CSTRAT)])
unused_age_LSPECs <- setdiff(available_age_LSPECs, used_age_LSPECs)

if(length(unused_age_LSPECs) > 0) {
  cat("\nLSPECs in age data without morphological matches:\n")
  print(head(unused_age_LSPECs, 20))  # Show first 20
  if(length(unused_age_LSPECs) > 20) {
    cat("... and", length(unused_age_LSPECs) - 20, "more\n")
  }
}
```

## Save Merged Dataset
```{r Save Merged Data}
# Write the merged dataset
write.csv(morph_with_age, 
          file = paste0(p$data.intermediate, "morph_with_age.csv"),
          row.names = FALSE)

# Create a summary report of the merge
merge_report <- list(
  merge_summary = merge_summary,
  missing_age_LSPECs = missing_age_LSPEC,
  unused_age_LSPECs = unused_age_LSPECs,
  total_age_records = nrow(age_formatted),
  total_morph_records = nrow(merged_non_overlap),
  final_merged_records = nrow(morph_with_age)
)

# Save the merge report
saveRDS(merge_report, file = paste0(p$processed, "/age_merge_report.rds"))

cat("\nMerge completed successfully!")
cat("\nMerged dataset saved to:", paste0(p$data.intermediate, "/morph_with_age.csv"))
cat("\nMerge report saved to:", paste0(p$processed, "/age_merge_report.rds"))
```

## Visualization of Age Data Coverage
```{r Age Data Visualization}
# Create visualizations to understand the age data coverage

# 1. Distribution of specimens across stratigraphic levels
if(sum(!is.na(morph_with_age$CSTRAT)) > 0) {
  
  p1 <- ggplot(morph_with_age %>% filter(!is.na(CSTRAT)), 
               aes(x = CSTRAT)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    labs(title = "Distribution of Specimens by Stratigraphic Level (CSTRAT)",
         x = "Stratigraphic Level (cm)",
         y = "Number of Specimens") +
    theme_minimal()
  
  print(p1)
  ggsave(paste0(p$results.figures.morphology, "specimens_by_strat_level.svg"), p1, width = 8, height = 6)
  
  # 2. Age distribution
  p2 <- ggplot(morph_with_age %>% filter(!is.na(YEAR)), 
               aes(x = YEAR)) +
    geom_histogram(bins = 30, fill = "lightgreen", color = "black") +
    labs(title = "Distribution of Specimens by Age (YEAR)",
         x = "Age (years)",
         y = "Number of Specimens") +
    theme_minimal() +
    scale_x_continuous(labels = scales::comma)
  
  print(p2)
  ggsave(paste0(p$results.figures.morphology, "specimens_by_age.svg"), p2, width = 8, height = 6)

  
  # 3. Relationship between CSTRAT and ISTRAT
  if(sum(!is.na(morph_with_age$ISTRAT)) > 0) {
    p3 <- ggplot(morph_with_age %>% filter(!is.na(CSTRAT) & !is.na(ISTRAT)), 
                 aes(x = CSTRAT, y = ISTRAT)) +
      geom_point(alpha = 0.6) +
      geom_smooth(method = "lm", se = TRUE, color = "red") +
      labs(title = "Relationship between CSTRAT and ISTRAT",
           x = "CSTRAT (cm)",
           y = "ISTRAT (cm)") +
      theme_minimal()
    
    print(p3)
    ggsave(paste0(p$results.figures.morphology, "cstrat_vs_istrat.svg"), p3, width = 8, height = 6)
  }
}
```

## Trait Evolution Over Time
```{r Trait Evolution Visualization}
# Get the continuous variables for trait evolution analysis
var_map <- variable_mapping()
continuous_vars <- var_map$continuous

# Prepare data for trait evolution analysis
trait_evolution_data <- morph_with_age %>%
  # Only include specimens with age data
  filter(!is.na(YEAR) & !is.na(CSTRAT)) %>%
  # Convert to long format for easier plotting
  pivot_longer(
    cols = all_of(continuous_vars),
    names_to = "trait",
    values_to = "value"
  ) %>%
  # Remove rows with missing trait values
  filter(!is.na(value)) %>%
  # Calculate sample sizes per trait for reference
  group_by(trait) %>%
  mutate(
    n_specimens = n(),
    trait_label = paste0(trait, " (n=", n_specimens, ")")
  ) %>%
  ungroup()

# Basic age distribution of specimens with trait data
p_age_dist <- ggplot(morph_with_age %>% filter(!is.na(YEAR)), 
                     aes(x = YEAR)) +
  geom_histogram(bins = 30, fill = "lightblue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of Specimens with Age Data",
       x = "Age (years)",
       y = "Number of Specimens") +
  theme_minimal() +
  scale_x_continuous(labels = scales::comma)

print(p_age_dist)

# Multi-panel trait evolution over time (using YEAR)
if(nrow(trait_evolution_data) > 0) {
  
  p_traits_time <- ggplot(trait_evolution_data, aes(x = YEAR, y = value)) +
    geom_point(alpha = 0.4, size = 0.8) +
    geom_smooth(method = "loess", se = TRUE, color = "red", size = 0.8) +
    facet_wrap(~ trait_label, scales = "free_y", ncol = 3) +
    labs(title = "Morphological Trait Evolution Over Time",
         x = "Age (years)",
         y = "Trait Value") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.text = element_text(size = 10)
    ) +
    scale_x_continuous(labels = scales::comma)
  
  print(p_traits_time)
  
  # Alternative view: traits over stratigraphic position (CSTRAT)
  p_traits_strat <- ggplot(trait_evolution_data, aes(x = CSTRAT, y = value)) +
    geom_point(alpha = 0.4, size = 0.8) +
    geom_smooth(method = "loess", se = TRUE, color = "blue", size = 0.8) +
    facet_wrap(~ trait_label, scales = "free_y", ncol = 3) +
    labs(title = "Morphological Traits Over Stratigraphic Position",
         x = "Stratigraphic Level (CSTRAT, cm)",
         y = "Trait Value") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.text = element_text(size = 10)
    )
  
  print(p_traits_strat)
  
  # Focus on body size (SL) evolution if available
  sl_data <- trait_evolution_data %>% filter(trait == "SL")
  
  if(nrow(sl_data) > 10) {  # Only if we have reasonable sample size
    p_sl_evolution <- ggplot(sl_data, aes(x = YEAR, y = value)) +
      geom_point(alpha = 0.6, size = 1.2, color = "darkblue") +
      geom_smooth(method = "loess", se = TRUE, color = "red", fill = "pink") +
      labs(title = "Body Size (Standard Length) Evolution Over Time",
           x = "Age (years)",
           y = "Standard Length (SL)",
           caption = paste("n =", nrow(sl_data), "specimens")) +
      theme_minimal() +
      scale_x_continuous(labels = scales::comma)
    
    print(p_sl_evolution)
  }
  
  # Summary statistics for trait trends
  trait_trends <- trait_evolution_data %>%
    group_by(trait) %>%
    summarise(
      n_specimens = n(),
      age_range_years = max(YEAR) - min(YEAR),
      correlation_with_age = cor(YEAR, value, use = "complete.obs"),
      mean_value = mean(value),
      sd_value = sd(value),
      .groups = "drop"
    ) %>%
    arrange(desc(abs(correlation_with_age)))
  
  cat("\nTrait correlations with age (strongest correlations first):\n")
  print(trait_trends)
  
} else {
  cat("No trait evolution data available - check if specimens have both age and trait measurements.\n")
}

ggsave(paste0(p$results.figures.morphology, "age_distribution.svg"), p_age_dist, width = 8, height = 6)
ggsave(paste0(p$results.figures.morphology, "traits_over_time.svg"), p_traits_time, width = 12, height = 8)
ggsave(paste0(p$results.figures.morphology, "traits_over_strat.svg"), p_traits_strat, width = 12, height = 8)
if(exists("p_sl_evolution")) ggsave(paste0(p$results.figures.morphology, "body_size_evolution.svg"), p_sl_evolution, width = 8, height = 6)
```

#==============================================================================#






